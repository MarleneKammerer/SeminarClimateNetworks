btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
# Here we map the another variable
Results_coll_r$carbonPricing <- beliefs.Ch$Carbon.Pricing
Group_cent_coll <- Results_coll_r %>%
mutate(actor.type = recode(carbonPricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "NA")) %>%
group_by(carbonPricing) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
View(coll.ch.net)
View(Group_cent_coll)
library(tidyverse)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
# Here we map the another variable
Results_coll_r$carbonPricing <- beliefs.Ch$Carbon.Pricing
Group_cent_coll <- Results_coll_r %>%
mutate(carbonPricing = recode(carbonPricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "NA")) %>%
group_by(carbonPricing) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
assortativity(coll.ch.net, beliefs.Ch$Carbon.Pricing )
View(beliefs.Ch)
View(beliefs.Ch)
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$CarbonPricing))
assortativity(coll.ch.net, Carbon_Pricing )
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$CarbonPricing))
assortativity(coll.ch.net, Carbon_Pricing )
library(tidyverse)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
# Here we map the another variable, i.e. Carbon Pricing
Results_coll_r$carbonPricing <- beliefs.Ch$Carbon.Pricing
Group_cent_coll <- Results_coll_r %>%
mutate(carbonPricing = recode(carbonPricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none")) %>%
group_by(carbonPricing) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
assortativity(coll.ch.net, CarbonPricing )
beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$CarbonPricing))
assortativity(coll.ch.net, beliefs.Ch$Carbon.Pricing)
assortativity(coll.ch.net, beliefs.Ch$Carbon.Pricing)
assortativity(coll.ch.net, beliefs.Ch$Carbon.Pricing, beliefs.Ch$Carbon.Pricing)
View(beliefs.Ch)
beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none"))
View(beliefs.Ch)
beliefs.Ch <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
assortativity(coll.ch.net, beliefs.Ch$Carbon.Pricing, beliefs.Ch$Carbon.Pricing)
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none"))
View(beliefs.Ch.recoded)
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", NA = "none"))
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
replace_na(Carbon.Pricing, "none")
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support")) %>%
replace_na(Carbon.Pricing, "none")
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support")) %>%
replace_na("none")
beliefs.Ch.recoded <- beliefs.Ch$Carbon.Pricing %>% replace_na(0)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
View(beliefs.Ch)
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
assortativity.nominal(coll.ch.net, V(coll.ch.net)$CarbonPricing)
assortativity(coll.ch.net, V(coll.ch.net)$CarbonPricing)
View(beliefs.Ch)
View(beliefs.Ch.recoded)
assortativity.nominal(coll.ch.net, beliefs.Ch.recoded$Carbon.Pricing)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$Carbon.Pricing))
assortativity.nominal(coll.ch.net, Carbon_Pricing)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$Carbon.Pricing))
assortativity(coll.ch.net, Carbon_Pricing)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$Carbon.Pricing))
assortativity(coll.ch.net, Carbon_Pricing, directed = FALSE)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(V(coll.ch.net)$Carbon.Pricing)
assortativity(coll.ch.net, Carbon_Pricing, directed = FALSE)
beliefs.Ch[is.na(beliefs.Ch)] <- 0
beliefs.Ch.recoded <- beliefs.Ch %>%
mutate(Carbon.Pricing = recode(Carbon.Pricing, "0" = "no answer", "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support"))
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Carbon.Pricing
Carbon_Pricing <- as.numeric(factor(V(coll.ch.net)$CarbonPricing))
assortativity(coll.ch.net, Carbon_Pricing)
V(coll.ch.net)$CarbonPricing <- beliefs.Ch$Regulatory.Measures
V(coll.ch.net)$Regulatory.Measures <- beliefs.Ch$Regulatory.Measures
Regulations <- as.numeric(factor(V(coll.ch.net)$Regulatory.Measures))
assortativity(coll.ch.net, Regulations)
V(coll.ch.net)$Subsidies <- beliefs.Ch$Subsidies
Subsidies <- as.numeric(factor(V(coll.ch.net)$Subsidies))
assortativity(coll.ch.net, Subsidies)
V(coll.ch.net)$Comp <- beliefs.Ch$Competitiveness
Comp <- as.numeric(factor(V(coll.ch.net)$Comp))
assortativity(coll.ch.net, Comp)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_2level.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
library(tidygraph)
library(ggraph)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
library(tidyverse)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
# Here we map the another variable, i.e. Carbon Pricing
Results_coll_r$carbonPricing <- beliefs.Ch$Carbon.Pricing
Group_cent_coll <- Results_coll_r %>%
mutate(carbonPricing = recode(carbonPricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none")) %>%
group_by(carbonPricing) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
V(coll.ch.net)$Regulatory.Measures <- beliefs.Ch$Regulatory.Measures
Regulations <- as.numeric(factor(V(coll.ch.net)$Regulatory.Measures))
assortativity(coll.ch.net, Regulations)
beliefs.ch[is.na(beliefs.ch)] <- 0
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_2level.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
library(tidygraph)
library(ggraph)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
library(tidyverse)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
# Here we map the another variable, i.e. Carbon Pricing
Results_coll_r$carbonPricing <- beliefs.Ch$Carbon.Pricing
Group_cent_coll <- Results_coll_r %>%
mutate(carbonPricing = recode(carbonPricing, "1" = "very low support",
"2" = "low support",
"3" = "neutral", "4" = "high support", "5"="very high support", "NA" = "none")) %>%
group_by(carbonPricing) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
beliefs.ch[is.na(beliefs.ch)] <- 0
beliefs.Ch[is.na(beliefs.Ch)] <- 0
V(coll.ch.net)$Regulatory.Measures <- beliefs.Ch$Regulatory.Measures
Regulations <- as.numeric(factor(V(coll.ch.net)$Regulatory.Measures))
assortativity(coll.ch.net, Regulations)
V(coll.ch.net)$Subsidies <- beliefs.Ch$Subsidies
Subsidies <- as.numeric(factor(V(coll.ch.net)$Subsidies))
assortativity(coll.ch.net, Subsidies)
V(coll.ch.net)$Comp <- beliefs.Ch$Competitiveness
Comp <- as.numeric(factor(V(coll.ch.net)$Comp))
assortativity(coll.ch.net, Comp)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_2level.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
library(tidygraph)
library(ggraph)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
# geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png",  width = 13, height = 10, dpi=300)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 0.5, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
# geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 0.1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
# geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png",  width = 13, height = 10, dpi=300)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 0.3, colour = "gray") +
geom_node_point(aes(size = centrality, colour = type)) +
# geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png",  width = 13, height = 10, dpi=300)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("Data/usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("Data/usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("Data/usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("Data/scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
# plot(sci.net) --> plotting takes forever
# dyads
dyad.census(inf.usa)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("Data/usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("Data/usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("Data/usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("Data/scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
# plot(sci.net) --> plotting takes forever
# dyads
dyad.census(inf.usa)
(package:igraph)
dyad.census(coll.usa)
# average path length
average.path.length(coll.net)
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
# plot(sci.net) --> plotting takes forever
