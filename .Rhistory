install.packages("rJava")
library (rJava)
.jinit()
.jcall("java/lang/System", "S", "getProperty", "java.version")
.jcall("java/lang/System", "S", "getProperty", "java.home")
.jcall("java/lang/System", "S", "getProperty", "os.arch") # java, Os and R architecture must match. In my case it is 64; amd 64 and x86_64
.jcall("java/lang/System", "S", "getProperty", "sun.arch.data.model")
install.packages("devtools")
devtools::install_github("leifeld/dna/rDNA", args = "--no-multiarch") # download rdNA from github
.jinit()
.jcall("java/lang/System", "S", "getProperty", "java.version")
.jcall("java/lang/System", "S", "getProperty", "java.home")
install.packages("rJava")
install.packages("rJava")
library (rJava)
.jinit()
.jcall("java/lang/System", "S", "getProperty", "java.version")
.jcall("java/lang/System", "S", "getProperty", "java.home")
.jcall("java/lang/System", "S", "getProperty", "os.arch") # java, Os and R architecture must match. In my case it is 64; amd 64 and x86_64
.jcall("java/lang/System", "S", "getProperty", "sun.arch.data.model")
R.Version()$arch
install.packages("devtools")
devtools::install_github("leifeld/dna/rDNA", args = "--no-multiarch") # download rdNA from github
mat <- matrix(nrow = 6, ncol = 4)
View(mat)
mat[2:3,] <- 0
mat[2:3,] <- 1
View(mat)
tmp_vec <- mat[3,]
vec_a <- list(3,5,9)
View(vec_a)
vec_a <- c(3,5,9)
vec_b <- c(1,4,10)
vec_c <- merge(vec_a, vec_b)
vec_c <- vec_a + vec_c
vec_c <- vec_a + vec_b
vec_c <- c(vec_a,vec_b)
rep()
vec_d <- rep(1:3, NA)
vec_d <- rep(1:3, "NA")
vec_d <- rep(1:3, 2)
vec_d
vec_d <- rep("NA", 3)
if (vec_c >= 9) {vec_d == vec_c}
vec_c <- vec_a + vec_b
vec_d <- rep("NA", 3)
if (vec_c >= 9) {vec_d == vec_c}
if (vec_c >= 9) {vec_d <- vec_c}
vec_d <- if(vec_c >= 9) vec_c else vec_d)
vec_d <- if(vec_c >= 9) vec_c else vec_d
mat[c(2,4),] <- 1
View(mat)
vec_d <- rep(NA, 3)
vec_d <- if(vec_c >= 9) vec_c else vec_d
?rep
vec_d[vec_c >=9] <- vec_c[vec_c >= 9]
vec_e <-rep(NA,3)
vec_e[vec_c == 3| vec == 9] = 100
vec_e[vec_c == 3| vec_C == 9] = 100
vec_e[vec_c == 3| vec_c == 9] = 100
vec_e[vec_a %in% c(3,9)] <- 100
mat2 <- matrix (1:16, nrow = 4, ncol=4)
for (i in 1:nrow(mat2)) {
root[i] <- sqrt (mat2[i,1])
}
root <- numeric ()
for (i in 1:nrow(mat2)) {
root[i] <- sqrt (mat2[i,1])
}
install.packages("rvest")
install.packages("stringr")
library(rvest)
library(stringr)
url <- "http://www.r-datacollection.com/materials/html/fortunes.html"
html <- read_html(url)
## Explicit path
xpath = "/html/body/div[2]/h1" #
html_nodes(html, xpath = xpath)
## Anywhere in the hierarchy (I scrape a header 1)
xpath = "//h1"
html_nodes(html, xpath = xpath)
## Attribute
xpath = "//a/@href"
html_nodes(html, xpath = xpath)
## Attribute with a particular value
xpath = "//div[@id ='R Inventor']"
html_nodes(html, xpath = xpath)
## Indexing
xpath = "//div[1]/p/i"
html_nodes(html, xpath = xpath)
url <- "https://cran.r-project.org/web/views/WebTechnologies.html"
library(rvest)
library(stringr)
url <- "https://cran.r-project.org/web/views/WebTechnologies.html"
html <- read_html(url)
## Explicit path
xpath = "/html/title"
html_nodes(html, xpath = xpath)
## Explicit path
xpath = "//title"
html_nodes(html, xpath = xpath)
## Anywhere in the hierarchy (I scrape a header 1)
xpath = "//<strong>"
html_nodes(html, xpath = xpath)
xpath = "//<strong>"
html_attr(html, xpath = xpath)
html_attr(html, xpath = xpath)
xpath = "//<strong>"
html_nodes(html, xpath = xpath)
xpath = "//strong"
html_nodes(html, xpath = xpath)
xpath = "//h2"
html_nodes(html, xpath = xpath)
xpath = "//h2[@id]"
html_nodes(html, xpath = xpath)
xpath = "//body/a href"
html_nodes(html, xpath = xpath)
xpath = "//body/a"
html_nodes(html, xpath = xpath)
xpath = "//body/div/p/a"
html_nodes(html, xpath = xpath)
xpath =
xpath = "//meta/content"
html_attrs(html, xpath =xpath)
xpath = "//meta/content"
html_nodes(html, xpath = xpath)
xpath = "//head/meta/content"
html_nodes(html, xpath = xpath)
xpath = "//head/meta/content[@name='citation_author']"
html_nodes(html, xpath = xpath)
View(html)
xpath = "/html/head/title"
html_nodes(html, xpath = xpath)
xpath = "//title"
html_nodes(html, xpath = xpath)
xpath = "//strong"
text_html<- html_nodes(html, xpath = xpath)
html_text (text_html)
xpath = "//h2[@id]"
text_html<- html_nodes(html, xpath = xpath)
html_text (text_html)
xpath = "//h2[@id]"
html_text (html_nodes(html, xpath = xpath))
xpath = "//body/a"
html_nodes(html, xpath = xpath)
xpath = "//body//a/@href"
html_nodes(html, xpath = xpath)
xpath = "//body//a/@href"
html_text(html_nodes(html, xpath = xpath))
xpath = "//meta[@name='citation_author']"
html_attrs (html_nodes(html, xpath = xpath))
attrs[[1]][2]
xpath = "//meta[@name='citation_author']"
attrs <- html_attrs (html_nodes(html, xpath = xpath))
attrs[[1]][2]
html_attr(nodes, name = "content")
xpath = <-"//link[1]"
xpath = "//link[1]"
html_nodes(html_nodes(html, xpath = xpath))
xpath = "//link[1]"
html_nodes(html, xpath = xpath)
html_attrs(html_nodes(html, xpath = xpath))
xpath = "//li//tt"
html_nodes(html, xpath = xpath)
exp(0.05)
exp(0.04)
setwd("C:/Users/kammerer/Dropbox/Comparative Paper COMPON/Analysis/Paul_CH")
library(sna)
library(ergm)
seed <- 12345
set.seed (seed)
#Import networks
coopSwiss <- read.csv(file="/Users/paulwagner/Desktop/CHFinSK_US/Switzerland/CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "/Users/paulwagner/Desktop/CHFinSK_US/Switzerland/CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="/Users/paulwagner/Desktop/CHFinSK_US/Switzerland/SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("/users/paulwagner/Desktop/CHFinSK_US/Switzerland/CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
#All beliefs
PBsSwiss <- PBsSwiss[,-c(1,2),]
#limited beliefs
PBsSwiss <- PBsSwiss[,-c(1,2,4,7),]
#contested beliefs
PBsSwiss <- PBsSwiss[,c(2,3,5,7)]
Pol.dist.Swiss <- dist(PBsSwiss, method = "manhattan")
PrefSimMatSwiss <- max(Pol.dist.Swiss) - Pol.dist.Swiss
PBsSwiss <-as.matrix(PrefSimMatSwiss)
#order of actor types for the nodefactor terms
f <- sort(unique(OrgTypeSwiss))
nodecov <- match(OrgTypeSwiss,f)
#"BUS" "CIV" "GOV" "NGO" "SCI"
#"BUS" "CIV" "GOV" "SCI"
#set attributes
nw.coopSwiss <- network(coopSwiss) # create network object
set.vertex.attribute (nw.coopSwiss, "OrgTypeSwiss", OrgTypeSwiss)
set.vertex.attribute (nw.coopSwiss, "Influence", degree (infSwiss, cmode = "indegree"))
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("/users/paulwagner/Desktop/CHFinSK_US/Switzerland/CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
#All beliefs
PBsSwiss <- PBsSwiss[,-c(1,2),]
#limited beliefs
PBsSwiss <- PBsSwiss[,-c(1,2,4,7),]
#contested beliefs
PBsSwiss <- PBsSwiss[,c(2,3,5,7)]
Pol.dist.Swiss <- dist(PBsSwiss, method = "manhattan")
PrefSimMatSwiss <- max(Pol.dist.Swiss) - Pol.dist.Swiss
PBsSwiss <-as.matrix(PrefSimMatSwiss)
#order of actor types for the nodefactor terms
f <- sort(unique(OrgTypeSwiss))
nodecov <- match(OrgTypeSwiss,f)
#"BUS" "CIV" "GOV" "NGO" "SCI"
#"BUS" "CIV" "GOV" "SCI"
#set attributes
nw.coopSwiss <- network(coopSwiss) # create network object
set.vertex.attribute (nw.coopSwiss, "OrgTypeSwiss", OrgTypeSwiss)
set.vertex.attribute (nw.coopSwiss, "Influence", degree (infSwiss, cmode = "indegree"))
Swiss7_d <- ergm(nw.coopSwiss ~ edges + edgecov(PBsSwiss) +
nodeifactor ("OrgTypeSwiss", base=c(1,2,4,5)) +
nodematch ("OrgTypeSwiss", diff = T) + nodefactor("OrgTypeSwiss", base=-c(2,3,4,5)) +
#nodeifactor ("OrgTypeSwiss", base=c(1,2,4)) +
#nodematch ("OrgTypeSwiss", diff = T) + nodefactor("OrgTypeSwiss", base=-c(2,3,4)) +
edgecov (infSwiss) + nodeicov("Influence") +
mutual + gwodegree(2.5, fixed = TRUE) + twopath + gwesp(0.1 , fixed = TRUE),
eval.loglik = TRUE, check.degeneracy = TRUE, control = control.ergm ( seed = seed , MCMC.samplesize = 1000 , MCMC.interval = 1000))
#set attributes
nw.coopSwiss <- network(coopSwiss) # create network object
set.vertex.attribute (nw.coopSwiss, "OrgTypeSwiss", OrgTypeSwiss)
set.vertex.attribute (nw.coopSwiss, "Influence", degree (infSwiss, cmode = "indegree"))
#Import networks
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("/users/paulwagner/Desktop/CHFinSK_US/Switzerland/CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
#All beliefs
PBsSwiss <- PBsSwiss[,-c(1,2),]
#limited beliefs
PBsSwiss <- PBsSwiss[,-c(1,2,4,7),]
#contested beliefs
PBsSwiss <- PBsSwiss[,c(2,3,5,7)]
Pol.dist.Swiss <- dist(PBsSwiss, method = "manhattan")
PrefSimMatSwiss <- max(Pol.dist.Swiss) - Pol.dist.Swiss
PBsSwiss <-as.matrix(PrefSimMatSwiss)
#order of actor types for the nodefactor terms
f <- sort(unique(OrgTypeSwiss))
nodecov <- match(OrgTypeSwiss,f)
#"BUS" "CIV" "GOV" "NGO" "SCI"
#"BUS" "CIV" "GOV" "SCI"
#set attributes
nw.coopSwiss <- network(coopSwiss) # create network object
set.vertex.attribute (nw.coopSwiss, "OrgTypeSwiss", OrgTypeSwiss)
set.vertex.attribute (nw.coopSwiss, "Influence", degree (infSwiss, cmode = "indegree"))
#Import networks
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
#All beliefs
PBsSwiss <- PBsSwiss[,-c(1,2),]
#limited beliefs
PBsSwiss <- PBsSwiss[,-c(1,2,4,7),]
#contested beliefs
PBsSwiss <- PBsSwiss[,c(2,3,5,7)]
Pol.dist.Swiss <- dist(PBsSwiss, method = "manhattan")
PrefSimMatSwiss <- max(Pol.dist.Swiss) - Pol.dist.Swiss
PBsSwiss <-as.matrix(PrefSimMatSwiss)
#order of actor types for the nodefactor terms
f <- sort(unique(OrgTypeSwiss))
nodecov <- match(OrgTypeSwiss,f)
#"BUS" "CIV" "GOV" "NGO" "SCI"
#"BUS" "CIV" "GOV" "SCI"
#set attributes
nw.coopSwiss <- network(coopSwiss) # create network object
set.vertex.attribute (nw.coopSwiss, "OrgTypeSwiss", OrgTypeSwiss)
set.vertex.attribute (nw.coopSwiss, "Influence", degree (infSwiss, cmode = "indegree"))
#Import networks
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
#All beliefs
PBsSwiss <- PBsSwiss[,-c(1,2),]
library(sna)
library(ergm)
seed <- 12345
set.seed (seed)
#Import networks
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
OrgTypeSwiss  <- as.character(OrgTypeSwiss )
OrgTypeSwiss  <- as.vector(OrgTypeSwiss )
#import and calculate beliefs distance matrix. Convert to 3 point Likert scale
PBsSwiss = read.csv("CH_Bfs.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(PBsSwiss) <- SwissOrgNames
colnames(PBsSwiss) <- SwissOrgNames
library(sna)
library(ergm)
seed <- 12345
set.seed (seed)
#Import networks
coopSwiss <- read.csv(file="CH_collab.csv",header=TRUE)
infSwiss <- read.csv(file= "CH_Inf.csv", header = TRUE)
OrgTypeSwiss <- read.csv(file="SwissOrgType.csv", header = TRUE)
coopSwiss <- as.matrix(coopSwiss)
infSwiss <- as.matrix(infSwiss)
diag (coopSwiss) <- 0
diag (infSwiss) <- 0
SwissOrgNames <- as.vector(colnames(coopSwiss))
OrgTypeSwiss  <-OrgTypeSwiss[,2 ] #When four actor types
OrgTypeSwiss  <-OrgTypeSwiss[,3 ] #When five actor types
install.packages("ergm")
install.packages("statnet")
install.packages("texreg")
install.packages("network")
install.packages("latticeExtra") # needed for GOF
library(ergm)
library(statnet)
library(texreg)
library(network)
seed <- 12345
set.seed (seed)
#Import data
OrgTypeCH <- read.csv2("Actor_CH.csv", header=TRUE)
library(ergm)
library(statnet)
library(texreg)
library(network)
seed <- 12345
set.seed (seed)
setwd("C:/Users/kammerer/OneDrive - Universitaet Bern/Lehre/UniBE_HS23/EnvPol1_networks/SeminarClimateNetworks")
OrgTypeCH <- read.csv2("Data/Actor_CH.csv", header=TRUE)
BeliefCH <- read.csv2("Data/Beliefs_CH.csv", header=TRUE)
BeliefCH$Name <- as.character(BeliefCH$Name)
RepCH <- read.csv2("Data/REP_CH.csv", header=TRUE)
setwd("C:/Users/kammerer/OneDrive - Universitaet Bern/Lehre/UniBE_HS23/EnvPol1_networks/SeminarClimateNetworks")
setwd("C:/Users/kammerer/OneDrive - Universitaet Bern/Lehre/UniBE_HS23/EnvPol1_networks/SeminarClimateNetworks")
