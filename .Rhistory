e <- array(1:12, c(2,3,2))
class(e)
e
m <- matrix(letters[1:12], ncol = 3, nrow = 4)
m
rownames(m) <- paste0("r_", 1:4)
colnames(m) <- paste0("c_", 1:3)
m
m[2, 2]
m["r_2", "c_2"]
m[2, "c_2"]
# Row
m[2, ]
m["r_2", ]
# Column
m[, 2]
m[, "c_2"]
# Cutout
m[1:2, 2:3]
m[c("r_1", "r_2"), c("c_2", "c_3")]
e <- array(letters[1:12], c(2,3,2))
dimnames(e) <- list(paste0("r_", 1:2), paste0("c_", 1:3), paste0("m_", 1:2))
e
e[1:2, 2, 2]
e[c("r_1", "r_2"), "c_2", "m_2"]
# 4. Vector to matrix
ev_mat <- matrix(data = ev, nrow = 6, ncol = 6)
# Define start point (2) and end point (70) as well as the steps of the sequence (2)
ev <- seq(2,70,2)
ev
# Show start and end of the result
head(ev)
tail(ev)
# Check the result: Length of the vector must be 35
length(ev)
# 4. Vector to matrix
ev_mat <- matrix(data = ev, nrow = 6, ncol = 6)
# 5. Subset
v_mat <- ev_mat[ev_mat >= 24] # Subset of the original matrix
v_mat <- ev_mat[ev_mat >= 24] # Subset of the original matrix
v_mat
class(v_mat)
dim(v_mat)
length(v_mat)
n_mat <- matrix(v_mat, 8, 3)
n_mat
t_mat <- t(n_mat)
t_mat
hello <- function(x)
{
x
print(paste0("Hello", x, "!"))
return(x)
}
hello(Carole)
hallo <- function(name) {
paste0("Hallo ", name, "!")
}
hallo("Daniel")
pythagoras <- function(a, b, c) {
a ^ 2 + b ^ 2 == c ^ 2
}
# Check function
pythagoras(3, 4, 5)
pythagoras(4, 5, 6)
recode_missings <- function(df) {
df[df == 99] <- NA
return(df)
}
df <- data.frame(replicate(6, sample(c(1:10, 99), 6, rep = TRUE)))
names(df) <- letters[1:6]
View(df)
recode_missings(df)
knitr::opts_chunk$set(echo = TRUE)
# library(tidygraph)
# library(ggraph)
library(igraph)
setwd("I:/Lehre/HS 2020/Env Pol 1 - Climate networks/Scripts/Week2")
att.usa <- read.csv2("usa_attributes.csv", header=TRUE)
View(att.usa)
coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
View(coll.usa)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
View(coll.usa)
inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
View(inf.usa)
sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
View(coll.mat)
View(coll.usa)
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
View(sci.mat)
sci.mat[sci.mat == 98] <- 0
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
vcount(coll.net)
ecount(coll.net)
table(sapply(cliques(coll.net), length))
dyad.census(coll.net)
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
set_vertex_attr(coll.net, "actorType", index = V(coll.net),  att.usa$OT_BIG)
list.vertex.attributes(coll.net) # check if covariates are loaded
set_vertex_attr(coll.net, "actorType", index = V(coll.net),  att.usa$OT_BIG)
get.vertex.attribute(coll.net)
set_vertex_attr(coll.net, "actorType", att.usa$OT_BIG)
View(att.usa)
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
rownames(att.usa) <- att.usa$ID
set_vertex_attr(coll.net, "actorType", att.usa$OT_BIG)
set_vertex_attr(coll.net, "actorType", index = V(coll.net), att.usa$OT_BIG)
list.vertex.attributes(coll.net) # check if covariates are loaded
View(att.usa)
View(att.usa)
View(att.usa)
set.vertex.attr(coll.net, "actorType", index = V(coll.net), att.usa$OT_BIG)
coll.net%v%"actorType" <- att.usa$OT_BIG
detach(package:igraph) # igraph will cause confusion with other packages, hence we need to detach it.
v(coll.net)$actorType <- att.usa$OT_BIG
# library(tidygraph)
# library(ggraph)
library(igraph)
V(coll.net)$actorType <- att.usa$OT_BIG
list.vertex.attributes(coll.net) # check if covariates are loaded
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
View(inf.usa)
View(sci.usa)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.net)
# triads
triad.census(coll.net)
# connectivity and paths
is.connected(coll.net)
# components (not really usful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
list.vertex.attributes(coll.net) # check if covariates are loaded
get.vertex.attribute(coll.net)
# detach(package:igraph) # igraph will cause confusion with other packages, hence we need to detach it.
## HINT: Very likely you will have to install these packages --> Google them to understand what they do.
library(sna)
library(GGally)
library(network)
library(ggplot2)
library(RColorBrewer)
library(intergraph)
library(scales)
net <- network(coll.mat) # this is a different way to creat a matrix object (using the network package); check the class!
# To add attributes here:
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
net%v%"actorType" <- att.usa$OT_BIG
# Adjust your color palette (tip: https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3)!
# Actor type code: 1=GOVERNMENT, 2=SCIENCE, 3=BUSINESS, 4=CIVIL SOCIETY
# Exmple on how to create a color palette for the actor type variable
palette = c("1" = "#252525", "2" = "#d9d9d9",
"3" ="#969696", "4" = "#737373")
# Adjust this code to your taste! If you don't know what to do, go and ask Dr. Google!
ggnet2(net, alpha = 0.75, label = TRUE, label.size = 3, mode = "kamadakawai",  node.size = 6, color = "actorType",
edge.size = 0.4,
color.legend = "actorType", edge.color = "grey", # maybe you have to adjust the name of the actorType variable here
palette = palette,
legend.size = 10, legend.position = "bottom")
ggsave("my_xxx_network.png", width = 29, height = 18,  device = NULL, dpi = 300) # now save your graph to your working directory
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
plot(sci.net)
View(inf.mat)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.net)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
View(inf.usa)
View(sci.usa)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
View(sci.mat)
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.mat)
# triads
triad.census(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.mat)
# triads
triad.census(coll.mat)
# connectivity and paths
is.connected(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.mat)
# triads
triad.census(coll.mat)
# connectivity and paths
is.connected(coll.mat)
# components (not really useful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
list.vertex.attributes(coll.net) # check if covariates are loaded
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
get.vertex.attribute(coll.net)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
View(inf.usa)
View(sci.usa)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.mat)
# triads
triad.census(coll.mat)
# connectivity and paths
is.connected(coll.mat)
# components (not really useful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
get.vertex.attribute(coll.net)
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
graph_attr_names(coll.net)
get.graph.attribute(coll.net)
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
get.graph.attribute(coll.net)
list.graph.attribute(coll.net)
list.graph.attributes(coll.net)
list.vertex.attributes(coll.net)
# dyads
dyad.census(inf.mat)
dyad.census(sci.mat)
dyad.census(coll.mat)
View(inf.mat)
# average path length
average.path.length(coll.net)
average.path.length(inf.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.mat)
# triads
triad.census(coll.mat)
# connectivity and paths
is.connected(coll.mat)
# components (not really useful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
# list.vertex.attributes(coll.net)
inf.mat <- as.matrix(inf.usa)
inf.u <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
inf.mat <- as.matrix(inf.usa)
inf.net <- graph.adjacency(inf.mat, mode="directed", diag=FALSE)
plot(inf.net)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
plot(sci.usa)
sci.mat <- as.matrix(sci.usa)
sci.net <- graph.adjacency(sci.mat, mode="directed", diag=FALSE)
plot(sci.net)
# average path length
average.path.length(coll.net)
average.path.length(inf.net)
average.path.length(sci.net)
diameter(coll.net)
diameter(inf.net)
diameter(sci.net)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
View(inf.usa)
View(coll.usa)
View(inf.usa)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
View(sci.usa)
View(coll.mat)
# number of nodes and edges
vcount(coll.net)
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.net)
# triads
triad.census(coll.net)
# connectivity and paths
is.connected(coll.net)
# components (not really useful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
att.usa$OT_BIG <- as.character(att.usa$OT_BIG)
V(coll.net)$actorType <- att.usa$OT_BIG
# list.vertex.attributes(coll.net)
