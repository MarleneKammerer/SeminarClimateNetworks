---
title: "Script No. 2"
author: "Marlene Kammerer"
date: "12 Oktober 2023"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = TRUE
)

```

# Network centrality {.tabset}

## Tutorial

### Content

  - Load packages 
  - Load the network data
  - Create network objects
  - calculate networks centrality statistics

### Install & load packages

Again, we work with the`igraph` package.

Do not forget to call `library(igraph)`.


```{r}

# install.packages("igraph") # to install the package 
library(igraph) # to load the package

```

### Load the network data

In this tutorial, we work with the US data again. For your exercises, you will work with a brand new Swiss dataset.


For more information on the US data you may have a look at ([Kammerer et al. 2021]https://onlinelibrary.wiley.com/doi/10.1111/psj.12422) 

```{r}
## Attributes

att.usa <- read.csv2("usa_attributes.csv", header=TRUE)

## Collaboration network

coll.usa <- read.csv2("usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL

## Influence network

inf.usa <- read.csv2("usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL

## Scientific information network

sci.usa <- read.csv2("scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
```

### Explore data sets

As usual, make sure that your datasets are correctly loaded. Check if there are NAs or any other issues that need to be resolved first.

```{r}

View(att.usa)
View(coll.usa)
View(inf.usa)
View(sci.usa)
```

### Create network objects

As usual we have to create network objects! This means to transform the data first into a matrix object (not dataframe) and then into a graph object.

#### First: Create matrices from data frames (only for "networks")

```{r}

coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)

# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.

coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0

```

#### Second: Create network object and visualize it in a first very simple plot

```{r}

coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)

```

### Explore network

Recall, in the last week, we did some basic analyses ...

```{r, eval=TRUE, echo=TRUE}

# number of nodes and edges

vcount(coll.net)
ecount(coll.net)

# cliques

table(sapply(cliques(coll.net), length))

# dyads

dyad.census(coll.net)

# triads

triad.census(coll.net)

# connectivity and paths

is.connected(coll.net)

# components (not really useful here)

comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))

# average path length

average.path.length(coll.net)

diameter(coll.net)

# is this network very connected?

```

### Network centrality

In the following, we calculate different network centrality statistics, such as

- Degree
- Betweeness
- closeness
- Eigenvector centrality 


We use a self-written function to calculate all these stats in one step and save them in a table. Also, we round the results.

```{r, eval=TRUE, echo=TRUE}
myCentrality <- function(net) {
  
  if (!is.igraph(net)) stop ("Input is not an igraph object")
  ideg <- degree (net, mode="in", loop=F, normalized = T)
  odeg <- degree (net, mode="out", loop=F, normalized = T)
  btw <- betweenness (net, normalized=TRUE)
  clo <- closeness (net, normalized=TRUE) # consider removing
  evc <- evcent(net)$vector
  id <- V(net)
  
  ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
                         Betweenness=btw, Closeness=clo,
                          Eigenvector=evc, ID=id))
  return(ret)
  
}

Results <- myCentrality(coll.net)
Results

# Round
Results_r <- data.frame(apply(Results[1:5],2, function(x) round(x, 3)))
```


### calculate network stats per actor type

But, what does this all mean? The numbers are for example more informative, if we look at them in an aggregated fashion. So, in this next code-chunk we calculate the average values of these statistics by actor type.

```{r, eval=TRUE, echo=TRUE}
library(tidyverse)

Results_r$actor.type <- as.factor(att.usa$OT_BIG)

Group_cent <- Results_r %>%
   mutate(actor.type = recode(actor.type, "1" = "GOV",
         "2" = "SCI",
         "3" = "BUS", "4" = "CIV", "5"="NA")) %>%
  group_by(actor.type) %>%
  summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent

```

## Exercises No. 2

1. Load the Swiss data into R (collaboration network, influence network, beliefs & actor type).
2. Create the collaboration and influence networks!
3. Do basic explorations (like census, diameter, av path length). What do we learn?
4. Assign actor type variable to the networks.
5. Plot the in and out degree distribution for both networks, arrange in one grid. Hint:https://stackoverflow.com/questions/1249548/side-by-side-plots-with-ggplot2
6. Calculate network statistics (e.g. degree, betweenness, closeness, eigenvector) that make sense for your the respective networks - justify your selection. What do the stats mean in the respective context?
7. Which actor group is most central in the collaboration network? Which is perceived as most influential? Who is the most influential actor? Who collaborates most? Who is most the most popular collaboration target?
5. Plot collaboration network with actor type as color code, arcs and degree stats reflecting node sizes. Add a legend to the figure.
6. Save your graph.

## Solutions No. 2
