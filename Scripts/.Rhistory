## Influence network
inf.usa <- read.csv2("Data/usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("Data/scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("igraph") # to install the package
library(igraph) # to load the package
## Attributes
att.usa <- read.csv2("Data/usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("Data7usa_collaboration.csv", header=TRUE)
## Attributes
att.usa <- read.csv2("Data/usa_attributes.csv", header=TRUE)
## Collaboration network
coll.usa <- read.csv2("Data/usa_collaboration.csv", header=TRUE)
rownames(coll.usa) <- coll.usa$ID
coll.usa$ID <- NULL
## Influence network
inf.usa <- read.csv2("Data/usa_influence.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(inf.usa) <- inf.usa $ID
inf.usa$ID <- NULL
## Scientific information network
sci.usa <- read.csv2("Data/scientific-information_USA.csv", header = TRUE, stringsAsFactors=FALSE)
rownames(sci.usa) <- sci.usa$ID
sci.usa$ID <- NULL
View(att.usa)
View(coll.usa)
View(inf.usa)
View(sci.usa)
coll.mat <- as.matrix(coll.usa)
inf.mat <- as.matrix(inf.usa)
sci.mat <- as.matrix(sci.usa)
# How to deal with NAs?? For the moment, we will recode them to 0. But, at later points we also discuss different strategies for treating NAs.
coll.mat[is.na(coll.mat)] <- 0
inf.mat[is.na(inf.mat)] <- 0
sci.mat[sci.mat == 98] <- 0
coll.mat <- as.matrix(coll.usa)
coll.net <- graph.adjacency(coll.mat, mode="directed", diag=FALSE)
plot(coll.net)
# number of nodes and edges
vcount(coll.net)
ecount(coll.net)
# cliques
table(sapply(cliques(coll.net), length))
# dyads
dyad.census(coll.net)
# triads
triad.census(coll.net)
# connectivity and paths
is.connected(coll.net)
# components (not really useful here)
comps <- decompose.graph(coll.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.net)
diameter(coll.net)
# is this network very connected?
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results <- myCentrality(coll.net)
Results
# Round
Results_r <- data.frame(apply(Results[1:5],2, function(x) round(x, 3)))
library(tidyverse)
Results_r$actor.type <- as.factor(att.usa$OT_BIG)
Group_cent <- Results_r %>%
mutate(actor.type = recode(actor.type, "1" = "GOV",
"2" = "SCI",
"3" = "BUS", "4" = "CIV", "5"="NA")) %>%
group_by(actor.type) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE)
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
View(coll.ch)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
View(inf.ch)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL- NULL
inf.ch$X <- NULL
View(beliefs.Ch)
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
types.ch <- read.csv2("CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
inf.ch.mat <- as.matrix(inf.ch) # transform dataset into matrix format
inf.ch.net <- graph.adjacency(inf.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
# number of nodes and edges
vcount(coll.ch.net)
ecount(coll.ch.net)
# cliques
table(sapply(cliques(coll.ch.net), length))
# dyads
dyad.census(coll.ch.net)
# triads
triad.census(coll.ch.net)
# connectivity and paths
is.connected(coll.ch.net)
# components (not really useful here)
comps <- decompose.graph(coll.ch.net)
table(sapply(comps, vcount))
# average path length
average.path.length(coll.ch.net)
diameter(coll.ch.net)
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
V(inf.ch.net)$type <- types.ch$Type
V(inf.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(inf.ch.net)
hist (degree(coll.ch.net, mode = "in", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(coll.ch.net, mode = "out", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(coll.ch.net, mode = "in", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(coll.ch.net, mode = "out", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(coll.ch.net, mode = "in", normalized = TRUE), col="yellow", xlim=c(0,0.4),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(coll.ch.net, mode = "out", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(inf.ch.net, mode = "in", normalized = TRUE), col="blue", xlim=c(0,0.4),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(inf.ch.net, mode = "out", normalized = TRUE), col="blue", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(inf.ch.net, mode = "in", normalized = TRUE), col="blue", xlim=c(0,0.6),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(inf.ch.net, mode = "out", normalized = TRUE), col="blue", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(inf.ch.net, mode = "in", normalized = TRUE), col="blue", xlim=c(0,0.8),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(inf.ch.net, mode = "out", normalized = TRUE), col="blue", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(inf.ch.net, mode = "in", normalized = TRUE), col="blue", xlim=c(0,0.8),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(inf.ch.net, mode = "out", normalized = TRUE), col="blue", xlim=c(0,0.8),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(coll.ch.net, mode = "in", normalized = TRUE), col="yellow", xlim=c(0,0.4),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(coll.ch.net, mode = "out", normalized = TRUE), col="yellow", xlim=c(0,0.6),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(coll.ch.net, mode = "in", normalized = TRUE), col="yellow", xlim=c(0,0.4),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(coll.ch.net, mode = "out", normalized = TRUE), col="yellow", xlim=c(0,0.8),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
par(mfrow=c(1,2))
hist (degree(inf.ch.net, mode = "in", normalized = TRUE), col="blue", xlim=c(0,0.8),
xlab = "Vertex Indegree", ylab="Frequency", main= "InDegree Distribution Switzerland")
hist (degree(inf.ch.net, mode = "out", normalized = TRUE), col="blue", xlim=c(0,0.8),
xlab = "Vertex Outdegree", ylab="Frequency", main= "OutDegree Distribution Switzerland")
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results <- myCentrality(coll.ch.net)
Results
# Round
Results_r <- data.frame(apply(Results[1:5],2, function(x) round(x, 3)))
library(tidyverse)
Results_r$actor.type <- types.ch$Type
Group_cent <- Results_r %>%
mutate(actor.type = recode(actor.type, "1" = "GOV",
"2" = "SCI",
"3" = "BUS", "4" = "CIV", "5"="NA")) %>%
group_by(actor.type) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
View(Results_coll_r)
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
Results_coll
# Round
Results_coll_r <- data.frame(apply(Results_coll[1:5],2, function(x) round(x, 3)))
Results_coll_r
Results_inf <- myCentrality(inf.ch.net)
Results_inf
# Round
Results_inf_r <- data.frame(apply(Results_inf[1:5],2, function(x) round(x, 3)))
Results_inf_r
library(tidyverse)
Results_coll_r$actor.type <- types.ch$Type
Group_cent_coll <- Results_r %>%
mutate(actor.type = recode(actor.type, "1" = "GOV",
"2" = "SCI",
"3" = "BUS", "4" = "CIV", "5"="NA")) %>%
group_by(actor.type) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_coll
library(tidyverse)
Results_inf_r$actor.type <- types.ch$Type
Group_cent <- Results_r %>%
mutate(actor.type = recode(actor.type, "1" = "GOV",
"2" = "SCI",
"3" = "BUS", "4" = "CIV", "5"="NA")) %>%
group_by(actor.type) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_inf
library(tidyverse)
Results_inf_r$actor.type <- types.ch$Type
Group_cent_inf <- Results_r %>%
mutate(actor.type = recode(actor.type, "1" = "GOV",
"2" = "SCI",
"3" = "BUS", "4" = "CIV", "5"="NA")) %>%
group_by(actor.type) %>%
summarise(mean_OD = mean(ODegree),  mean_ID = mean(IDegree), mean_Betw = mean(Betweenness), mean_clo=mean(Closeness), mean_Eig=mean(Eigenvector))
Group_cent_inf
library(sna) # another network package;
library(GGally)
library(network) # another network package;
library(ggplot2) # for plotting
library(RColorBrewer)
library(intergraph) # another network package;
library(scales)
library(tidyverse) # data management
net <- network(coll.ch.mat, directed = TRUE) # this is a different way to create a graph object (using the network package);
net%v%"actorType" <- types.CH$Type
net%v%"actorType" <- types.ch$Type
unique(types.CH$Type)
unique(types.chType)
unique(types.ch$Type)
palette = c("Government" = "#f03b20", "Science" = "#31a354",
"Business" ="#feb24c", "Civil society" = "#c51b8a", "Party" = "#2b8cbe")
ggnet2(net, alpha = 0.75, label = FALSE, label.size = 3, mode = "kamadakawai", node.size = 6, size = "indegree", color = "actorType",
arrow.size = 8, arrow.gap = 0.025,
shape.legend = "Actor Type",
color.legend = "actorType", edge.color = "grey", # maybe you have to adjust the name of the actorType variable here
palette = palette,
legend.size = 10, size.min = 1, size.cut = 5, size.legend = "8", legend.position = "bottom")
ggsave("Plots/my_CH_network.png", width = 29, height = 18,  device = NULL, dpi = 300)
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
install.packages("migraph") # to install the package
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
library(knitr)
library(tidygraph)
library(tidyverse)
library(ggraph)
library(igraph)
library(tidyr)
library(ggpubr)
library(ggplot2)
library(migraph)
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
library(knitr)
library(tidygraph)
library(tidyverse)
library(ggraph)
library(igraph)
library(tidyr)
library(ggpubr)
library(ggplot2)
library(migraph)
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE,
include = TRUE
)
# install.packages("migraph") # to install the package
library(igraph) # to load the package
## Attributes
beliefs.Ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
twolevel.ch <- read.csv2("Data/CH_beliefs.csv", header=TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
## Collaboration network
coll.ch <- read.csv2("Data/cH_coll.csv", header=TRUE)
rownames(coll.ch) <- coll.ch$X
coll.ch$X <- NULL
## Influence network
inf.ch <- read.csv2("Data/cH_influence.csv", header=TRUE)
rownames(inf.ch) <- inf.ch$X
inf.ch$X <- NULL
## Actor type
types.ch <- read.csv2("Data/CH_type.csv", header = TRUE, fileEncoding = "latin1", stringsAsFactors = FALSE)
coll.ch.mat <- as.matrix(coll.ch) # transform dataset into matrix format
coll.ch.net <- graph.adjacency(coll.ch.mat, mode="directed", diag=FALSE) # transform matrix into graph object
V(coll.ch.net)$type <- types.ch$Type
V(coll.ch.net)$klar <- types.ch$Klarname_EN
list.vertex.attributes(coll.ch.net)
library(tidygraph)
coll.ch.tidy <- as_tbl_graph(coll.ch.net)
set.seed(123)
coll.ch.tidy %>%
activate(nodes) %>%
mutate(centrality = centrality_authority()) %>% # to display node size based on degree centrality
ggraph(layout = "graphopt") +
geom_edge_link(width = 1, colour = "lightgray") +
geom_node_point(aes(size = centrality, colour = type)) +
geom_node_text(aes(label = klar), repel = TRUE)+
# scale_color_gradient(low = "yellow", high = "red")+
theme_graph()
ggsave("Plots/Climate_pol_net.png", dpi=300)
# First calculate the centralization statistics as ususal ...
myCentrality <- function(net) {
if (!is.igraph(net)) stop ("Input is not an igraph object")
ideg <- degree (net, mode="in", loop=F, normalized = T)
odeg <- degree (net, mode="out", loop=F, normalized = T)
btw <- betweenness (net, normalized=TRUE)
clo <- closeness (net, normalized=TRUE) # consider removing
evc <- evcent(net)$vector
id <- V(net)
ret <-data.frame (cbind(IDegree=ideg, ODegree=odeg,
Betweenness=btw, Closeness=clo,
Eigenvector=evc, ID=id))
return(ret)
}
Results_coll <- myCentrality(coll.ch.net)
